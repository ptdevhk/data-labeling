name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to deploy (e.g., v1.2.3)'
        required: true
        type: string
      enable_rollback:
        description: 'Enable auto-rollback on failure'
        required: false
        type: boolean
        default: true

env:
  # SSH connection settings (REQUIRED: configure via GitHub Repository Secrets)
  # DEPLOY_HOST must be set in GitHub Settings â†’ Secrets and variables â†’ Actions â†’ Secrets
  DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
  DEPLOY_USER: ${{ vars.DEPLOY_USER || 'ubuntu' }}
  DEPLOY_PORT: ${{ vars.DEPLOY_PORT || '22' }}
  # Deployment paths (can be overridden via vars)
  DEPLOY_PATH: ${{ vars.DEPLOY_PATH || '/home/ubuntu/data-labeling' }}
  # URLs for health checks and notifications
  PRODUCTION_URL: ${{ vars.PRODUCTION_URL || 'https://labeling.pt-mes.com' }}
  HEALTH_CHECK_URL: ${{ vars.HEALTH_CHECK_URL || 'http://localhost:5002/health' }}

concurrency:
  group: production-deploy
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy Release to Production
    runs-on: ubuntu-latest
    # Note: Using repository secrets directly (not environment secrets) for easier management
    # To use environment-level secrets, uncomment: environment: production
    timeout-minutes: 15

    steps:
      - name: Check required configuration
        run: |
          if [ -z "${{ secrets.DEPLOY_HOST }}" ]; then
            echo "::error::DEPLOY_HOST secret is not set!"
            echo "Please configure DEPLOY_HOST in GitHub â†’ Settings â†’ Secrets and variables â†’ Actions â†’ Secrets"
            exit 1
          fi
          echo "DEPLOY_HOST is configured"

      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          # Always checkout main/default branch for latest deploy scripts
          # The server-side script handles checking out the specific version
          ref: ${{ github.event.repository.default_branch || 'main' }}
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

      - name: Configure SSH connection
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ env.DEPLOY_PORT }} -H ${{ env.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

          # Configure SSH multiplexing to reuse single connection
          cat >> ~/.ssh/config << EOF
          Host ${{ env.DEPLOY_HOST }}
            Port ${{ env.DEPLOY_PORT }}
            ControlMaster auto
            ControlPath ~/.ssh/ctrl-%C
            ControlPersist 300
            ServerAliveInterval 60
            ServerAliveCountMax 3
            ConnectTimeout 30
            BatchMode yes
          EOF
          chmod 600 ~/.ssh/config

      - name: Verify SSH connection
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} "echo 'SSH connection established - master socket created'"

      - name: Deploy to production
        id: deploy
        run: |
          # Copy script and execute in single SSH session (reuses master socket)
          scp bin/deploy-production.sh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:/tmp/

          ROLLBACK_FLAG=""
          if [ "${{ github.event.inputs.enable_rollback }}" == "true" ] || [ "${{ github.event_name }}" == "release" ]; then
            ROLLBACK_FLAG="rollback"
          fi

          ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} \
            "chmod +x /tmp/deploy-production.sh && /tmp/deploy-production.sh '${{ steps.version.outputs.version }}' $ROLLBACK_FLAG"

      - name: Verify deployment
        run: |
          sleep 5
          ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} "curl -sf ${{ env.HEALTH_CHECK_URL }}" || {
            echo "Internal health check failed"
            exit 1
          }
          echo "Deployment verified successfully"

      - name: Cleanup SSH connection
        if: always()
        run: |
          # Gracefully close master connection
          ssh -O exit ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} 2>/dev/null || true

      - name: Create deployment summary
        if: always()
        run: |
          {
            echo "## Deployment Summary"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| **Status** | ${{ job.status }} |"
            echo "| **Version** | ${{ steps.version.outputs.version }} |"
            echo "| **Environment** | production |"
            echo "| **URL** | ${{ env.PRODUCTION_URL }} |"
            echo "| **Triggered by** | ${{ github.event_name }} |"
            echo "| **Actor** | @${{ github.actor }} |"
            echo "| **Time** | $(date -u +'%Y-%m-%d %H:%M:%S UTC') |"
          } >> $GITHUB_STEP_SUMMARY

      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Production deployment failed: ${{ steps.version.outputs.version }}`,
              body: `## Deployment Failure

              **Version:** ${{ steps.version.outputs.version }}
              **Workflow run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}
              **Actor:** @${{ github.actor }}

              Please investigate and resolve the issue.`,
              labels: ['deployment', 'bug', 'urgent']
            });
            console.log(`Created issue: ${issue.data.html_url}`);
